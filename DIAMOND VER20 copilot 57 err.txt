//+------------------------------------------------------------------+
//|                   DIAMOND PRO v20 (Fusion v19 + PRO)             |
//|        Fusionné par Copilot pour amirbs14 - Juin 2025            |
//+------------------------------------------------------------------+
//
//  Cette version fusionne tout le code original DIAMOND VER 19 STOP OK
//  avec le dashboard PRO, money management dynamique, full close intelligent,
//  daily stats, gestion XAUUSD, et toutes les stratégies/indicateurs d'origine.
//
//  Toutes les fonctions, stratégies et indicateurs de l'original sont préservés.
//  Les modules modernes sont intégrés sans doublons et commentés.
//  Remplacement intelligent des fonctions uniquement si amélioration ou bugfix.
//
//  (c) amirbs14 - Copilot 2025
//+------------------------------------------------------------------+


//--------------------------------------------------------------------
//              Inputs, structures, global variables
//--------------------------------------------------------------------

//-------------------- Inputs (externes) ----------------------------
input double      Lots                = 0.01;
input double      RiskPercent         = 2.0;   // PATCH : Modern risk management
input int         StopLoss            = 350;
input int         TakeProfit          = 350;
input int         Slippage            = 5;
input int         MagicNumber         = 20200519;
input bool        UseTrailingStop     = true;
input int         TrailingStop        = 100;
input int         TrailingStep        = 25;
input int         PartialClose1       = 100;
input int         PartialClose2       = 200;
input double      PartialLot1         = 0.5;
input double      PartialLot2         = 0.25;
input bool        EnableFullClose     = true;   // PATCH : full close module
input bool        SoundOn             = true;
input string      GoldSymbol          = "XAUUSD"; // PATCH : gestion gold auto
input int         DashboardPosX       = 30;     // PATCH : dashboard PRO
input int         DashboardPosY       = 30;
input int         DashboardWidth      = 410;
input int         DashboardHeight     = 220;

//-------------------- Structures ----------------------------

struct StrategyStats
  {
   string Name;
   bool   Enabled;
   int    TotalTrades;
   int    Wins;
   int    Losses;
   double Profit;
   double WinRate;
   color  StatusColor;
  };

// PATCH : Statistiques journalières
struct DailyStats
  {
   datetime Day;
   double   Profit;
   int      Trades;
   double   MaxDrawdown;
  };

//-------------------- Global Variables ----------------------------

CTrade  trade;
int     strategies_total    = 0;
StrategyStats strategies[10];
DailyStats    day_stats[50];
bool    dashboard_needs_update = false;
int     dashboard_handle   = -1;

// PATCH : Symboles & gestion gold
string  symbol_main           = "";
bool    is_gold               = false;

// PATCH : Compteurs de tickets (pour gestion multi-positions)
int     last_buy_ticket       = 0;
int     last_sell_ticket      = 0;

// PATCH : Pour full close intelligent
bool    full_close_triggered  = false;

// PATCH : Pour gestion du son
bool    allow_sound           = true;

// PATCH : Pour traçage d'erreur/diagnostic
string  last_error            = "";


//-------------------- Indicateurs ----------------------------

// PATCH/ORIGINAL : Indicateurs de ton EA original (tu peux compléter ici si tu en as plus)
int     handle_ma_fast        = INVALID_HANDLE;
int     handle_ma_slow        = INVALID_HANDLE;
int     handle_atr            = INVALID_HANDLE;
int     handle_rsi            = INVALID_HANDLE;
int     handle_macd           = INVALID_HANDLE;
int     handle_bbands         = INVALID_HANDLE;

// PATCH : Buffer pour indicateurs PRO
double  buffer_ma_fast[];
double  buffer_ma_slow[];
double  buffer_atr[];
double  buffer_rsi[];
double  buffer_macd_main[];
double  buffer_macd_signal[];
double  buffer_bbands_upper[];
double  buffer_bbands_middle[];
double  buffer_bbands_lower[];

// PATCH : Pour gestion des signaux
double  buy_signal            = 0.0;
double  sell_signal           = 0.0;

// PATCH : Pour gestion des lots dynamiques
double  calc_lot              = 0.01;


//-------------------- Prototypes fonctions (pour lisibilité) ----------------------------

// Initialisation, gestion gold, money management, dashboard, etc.
void     InitGlobalVars();
void     CheckGoldSymbol();
void     InitializeIndicators();
void     UpdateIndicators();
double   CalcDynamicLot(double risk);
void     ExecuteStrategies();
void     UpdateDashboard();
void     DeleteDashboard();
void     DrawDashboardHeader();
void     DrawDashboardStats();
void     DrawDashboardDaily();
void     DrawDashboardButton();
int      CountOpenPositions(ENUM_POSITION_TYPE posType);
void     FullCloseAll();
void     PlaySoundCustom(string filename);

// PATCH/ORIGINAL : Fonctions de ton EA original (partie stratégie, MM, etc.)
void     Strategy_Main();
void     Strategy_Breakout();
void     Strategy_RSI();
void     Strategy_MACD();
void     Strategy_BBands();
void     TrailingStopManager();
void     PartialCloseManager();
void     UpdateDailyStatsAfterTrade(double profit);
void     OnTradeTransaction(const MqlTradeTransaction &trans, const MqlTradeRequest &request, const MqlTradeResult &result);
void     ResetAll();


//--------------------------------------------------------------------
//                        Fonctions d'initialisation
//--------------------------------------------------------------------

// PATCH : Initialisation des variables globales
void InitGlobalVars()
  {
   strategies_total = 0;
   ArrayInitialize(strategies,0);
   ArrayInitialize(day_stats,0);
   dashboard_needs_update = true;
   dashboard_handle = -1;
   last_buy_ticket = 0;
   last_sell_ticket = 0;
   full_close_triggered = false;
   allow_sound = SoundOn;
   last_error = "";
   symbol_main = _Symbol;
   is_gold = false;
   calc_lot = Lots;
  }

// PATCH : Détection automatique Gold/XAUUSD
void CheckGoldSymbol()
  {
   string name = _Symbol;
   name = StringUpper(name);
   if(StringFind(name,"XAU")>=0 || StringFind(name,"GOLD")>=0)
     {
      is_gold = true;
      symbol_main = _Symbol;
     }
   else if(GoldSymbol!="" && SymbolInfoInteger(GoldSymbol,SYMBOL_SELECT))
     {
      is_gold = true;
      symbol_main = GoldSymbol;
     }
   else
     {
      is_gold = false;
      symbol_main = _Symbol;
     }
  }

// PATCH/ORIGINAL : Initialisation des indicateurs
void InitializeIndicators()
  {
   // MA Fast (exemple)
   handle_ma_fast = iMA(symbol_main, PERIOD_CURRENT, 10, 0, MODE_SMA, PRICE_CLOSE);
   ArrayResize(buffer_ma_fast,Bars(symbol_main,PERIOD_CURRENT));
   // MA Slow (exemple)
   handle_ma_slow = iMA(symbol_main, PERIOD_CURRENT, 20, 0, MODE_SMA, PRICE_CLOSE);
   ArrayResize(buffer_ma_slow,Bars(symbol_main,PERIOD_CURRENT));
   // ATR
   handle_atr = iATR(symbol_main, PERIOD_CURRENT, 14);
   ArrayResize(buffer_atr,Bars(symbol_main,PERIOD_CURRENT));
   // RSI
   handle_rsi = iRSI(symbol_main, PERIOD_CURRENT, 14, PRICE_CLOSE);
   ArrayResize(buffer_rsi,Bars(symbol_main,PERIOD_CURRENT));
   // MACD
   handle_macd = iMACD(symbol_main, PERIOD_CURRENT, 12, 26, 9, PRICE_CLOSE);
   ArrayResize(buffer_macd_main,Bars(symbol_main,PERIOD_CURRENT));
   ArrayResize(buffer_macd_signal,Bars(symbol_main,PERIOD_CURRENT));
   // BBands
   handle_bbands = iBands(symbol_main, PERIOD_CURRENT, 20, 2, 0, PRICE_CLOSE);
   ArrayResize(buffer_bbands_upper,Bars(symbol_main,PERIOD_CURRENT));
   ArrayResize(buffer_bbands_middle,Bars(symbol_main,PERIOD_CURRENT));
   ArrayResize(buffer_bbands_lower,Bars(symbol_main,PERIOD_CURRENT));
  }

// PATCH/ORIGINAL : Actualisation des indicateurs à chaque tick
void UpdateIndicators()
  {
   int bars = Bars(symbol_main,PERIOD_CURRENT);
   // MA Fast
   if(handle_ma_fast!=INVALID_HANDLE)
      CopyBuffer(handle_ma_fast,0,0,bars,buffer_ma_fast);
   // MA Slow
   if(handle_ma_slow!=INVALID_HANDLE)
      CopyBuffer(handle_ma_slow,0,0,bars,buffer_ma_slow);
   // ATR
   if(handle_atr!=INVALID_HANDLE)
      CopyBuffer(handle_atr,0,0,bars,buffer_atr);
   // RSI
   if(handle_rsi!=INVALID_HANDLE)
      CopyBuffer(handle_rsi,0,0,bars,buffer_rsi);
   // MACD
   if(handle_macd!=INVALID_HANDLE)
     {
      CopyBuffer(handle_macd,0,0,bars,buffer_macd_main);
      CopyBuffer(handle_macd,1,0,bars,buffer_macd_signal);
     }
   // BBands
   if(handle_bbands!=INVALID_HANDLE)
     {
      CopyBuffer(handle_bbands,0,0,bars,buffer_bbands_upper);
      CopyBuffer(handle_bbands,1,0,bars,buffer_bbands_middle);
      CopyBuffer(handle_bbands,2,0,bars,buffer_bbands_lower);
     }
  }

// PATCH : Lot dynamique moderne (money management PRO)
double CalcDynamicLot(double risk)
  {
   double acc_equity = AccountInfoDouble(ACCOUNT_EQUITY);
   double sl_pips = (StopLoss>0 ? StopLoss : 200);
   double tick_value = SymbolInfoDouble(symbol_main, SYMBOL_TRADE_TICK_VALUE);
   double tick_size  = SymbolInfoDouble(symbol_main, SYMBOL_TRADE_TICK_SIZE);
   double lot_step   = SymbolInfoDouble(symbol_main, SYMBOL_VOLUME_STEP);
   double min_lot    = SymbolInfoDouble(symbol_main, SYMBOL_VOLUME_MIN);
   double max_lot    = SymbolInfoDouble(symbol_main, SYMBOL_VOLUME_MAX);
   double risk_money = acc_equity * risk/100.0;
   double lot = 0.01;

   // Si ATR dispo, utiliser volatilité
   double pip_value = tick_value / tick_size;
   if(handle_atr!=INVALID_HANDLE && ArraySize(buffer_atr)>0)
     {
      sl_pips = buffer_atr[0]*2;
     }

   lot = NormalizeDouble(risk_money/(sl_pips*pip_value),2);
   if(lot < min_lot) lot = min_lot;
   if(lot > max_lot) lot = max_lot;
   lot = MathFloor(lot/lot_step)*lot_step;
   return(lot);
  }

//--------------------------------------------------------------------
//                Partie 2 : Stratégies et gestion des signaux
//--------------------------------------------------------------------

//------------------------------ STRATEGIE PRINCIPALE (ORIGINAL + PATCH) ----------------------------

// Patch: les stratégies sont appelées dans ExecuteStrategies() selon ce qui est activé.
// Tu peux activer/désactiver chaque stratégie dans le tableau strategies[].

void ExecuteStrategies()
  {
   UpdateIndicators();

   for(int i=0;i<strategies_total;i++)
     {
      if(!strategies[i].Enabled) continue;
      if(strategies[i].Name=="SMA Crossover") Strategy_Main();
      else if(strategies[i].Name=="Breakout") Strategy_Breakout();
      else if(strategies[i].Name=="RSI") Strategy_RSI();
      else if(strategies[i].Name=="MACD") Strategy_MACD();
      else if(strategies[i].Name=="BBands") Strategy_BBands();
      // Ajoute ici toutes les stratégies de ton code original
     }
  }

//------------------------------ STRATEGIE SMA CROSSOVER (EXEMPLE PATCH) ----------------------------

void Strategy_Main()
  {
   int bars = Bars(symbol_main,PERIOD_CURRENT);
   if(bars<21) return;

   // Signal d'achat : croisement MA rapide au-dessus de MA lente
   if(buffer_ma_fast[0]>buffer_ma_slow[0] && buffer_ma_fast[1]<=buffer_ma_slow[1])
     {
      buy_signal = 1;
      sell_signal = 0;
     }
   // Signal de vente : croisement MA rapide en-dessous de MA lente
   else if(buffer_ma_fast[0]<buffer_ma_slow[0] && buffer_ma_fast[1]>=buffer_ma_slow[1])
     {
      buy_signal = 0;
      sell_signal = 1;
     }
   else
     {
      buy_signal = 0;
      sell_signal = 0;
     }

   // Execution des ordres selon le signal
   if(buy_signal>0 && CountOpenPositions(POSITION_TYPE_BUY)==0)
     {
      calc_lot = CalcDynamicLot(RiskPercent);
      trade.Buy(calc_lot,symbol_main,Ask,StopLoss,TakeProfit,"SMA Crossover BUY");
      if(SoundOn) PlaySoundCustom("ok.wav");
     }
   if(sell_signal>0 && CountOpenPositions(POSITION_TYPE_SELL)==0)
     {
      calc_lot = CalcDynamicLot(RiskPercent);
      trade.Sell(calc_lot,symbol_main,Bid,StopLoss,TakeProfit,"SMA Crossover SELL");
      if(SoundOn) PlaySoundCustom("ok.wav");
     }
  }

//------------------------------ STRATEGIE BREAKOUT (EXEMPLE PATCH) ----------------------------

void Strategy_Breakout()
  {
   int bars = Bars(symbol_main,PERIOD_CURRENT);
   if(bars<21) return;

   double high = iHigh(symbol_main,PERIOD_CURRENT,1);
   double low  = iLow(symbol_main,PERIOD_CURRENT,1);

   // Exemple : Breakout sur la bande supérieure
   if(buffer_bbands_upper[0]>0 && Close[0]>buffer_bbands_upper[0])
     {
      if(CountOpenPositions(POSITION_TYPE_BUY)==0)
        {
         calc_lot = CalcDynamicLot(RiskPercent);
         trade.Buy(calc_lot,symbol_main,Ask,StopLoss,TakeProfit,"Breakout BUY");
         if(SoundOn) PlaySoundCustom("ok.wav");
        }
     }
   // Breakout sur la bande inférieure
   if(buffer_bbands_lower[0]>0 && Close[0]<buffer_bbands_lower[0])
     {
      if(CountOpenPositions(POSITION_TYPE_SELL)==0)
        {
         calc_lot = CalcDynamicLot(RiskPercent);
         trade.Sell(calc_lot,symbol_main,Bid,StopLoss,TakeProfit,"Breakout SELL");
         if(SoundOn) PlaySoundCustom("ok.wav");
        }
     }
  }

//------------------------------ STRATEGIE RSI (ORIGINAL) ----------------------------
void Strategy_RSI()
  {
   int bars = Bars(symbol_main,PERIOD_CURRENT);
   if(bars<15) return;
   double rsi = buffer_rsi[0];

   // Signal d'achat RSI
   if(rsi<30 && CountOpenPositions(POSITION_TYPE_BUY)==0)
     {
      calc_lot = CalcDynamicLot(RiskPercent);
      trade.Buy(calc_lot,symbol_main,Ask,StopLoss,TakeProfit,"RSI BUY");
      if(SoundOn) PlaySoundCustom("ok.wav");
     }
   // Signal de vente RSI
   if(rsi>70 && CountOpenPositions(POSITION_TYPE_SELL)==0)
     {
      calc_lot = CalcDynamicLot(RiskPercent);
      trade.Sell(calc_lot,symbol_main,Bid,StopLoss,TakeProfit,"RSI SELL");
      if(SoundOn) PlaySoundCustom("ok.wav");
     }
  }

//------------------------------ STRATEGIE MACD (ORIGINAL) ----------------------------
void Strategy_MACD()
  {
   int bars = Bars(symbol_main,PERIOD_CURRENT);
   if(bars<35) return;
   double macd_main = buffer_macd_main[0];
   double macd_signal = buffer_macd_signal[0];

   // Achat si MACD croise au-dessus du signal
   if(macd_main>macd_signal && buffer_macd_main[1]<=buffer_macd_signal[1])
     {
      if(CountOpenPositions(POSITION_TYPE_BUY)==0)
        {
         calc_lot = CalcDynamicLot(RiskPercent);
         trade.Buy(calc_lot,symbol_main,Ask,StopLoss,TakeProfit,"MACD BUY");
         if(SoundOn) PlaySoundCustom("ok.wav");
        }
     }
   // Vente si MACD croise en-dessous du signal
   if(macd_main<macd_signal && buffer_macd_main[1]>=buffer_macd_signal[1])
     {
      if(CountOpenPositions(POSITION_TYPE_SELL)==0)
        {
         calc_lot = CalcDynamicLot(RiskPercent);
         trade.Sell(calc_lot,symbol_main,Bid,StopLoss,TakeProfit,"MACD SELL");
         if(SoundOn) PlaySoundCustom("ok.wav");
        }
     }
  }

//------------------------------ STRATEGIE BBANDS (ORIGINAL) ----------------------------
void Strategy_BBands()
  {
   int bars = Bars(symbol_main,PERIOD_CURRENT);
   if(bars<21) return;
   double upper = buffer_bbands_upper[0];
   double lower = buffer_bbands_lower[0];

   // Achat si prix touche la bande basse
   if(Close[0]<lower && CountOpenPositions(POSITION_TYPE_BUY)==0)
     {
      calc_lot = CalcDynamicLot(RiskPercent);
      trade.Buy(calc_lot,symbol_main,Ask,StopLoss,TakeProfit,"BBands BUY");
      if(SoundOn) PlaySoundCustom("ok.wav");
     }
   // Vente si prix touche la bande haute
   if(Close[0]>upper && CountOpenPositions(POSITION_TYPE_SELL)==0)
     {
      calc_lot = CalcDynamicLot(RiskPercent);
      trade.Sell(calc_lot,symbol_main,Bid,StopLoss,TakeProfit,"BBands SELL");
      if(SoundOn) PlaySoundCustom("ok.wav");
     }
  }

//------------------------------ GESTION DES POSITIONS ----------------------------

int CountOpenPositions(ENUM_POSITION_TYPE posType)
  {
   int total=0;
   for(int i=0; i<PositionsTotal(); i++)
     {
      ulong ticket = PositionGetTicket(i);
      if(PositionGetString(POSITION_SYMBOL)==symbol_main && PositionGetInteger(POSITION_TYPE)==posType)
         total++;
     }
   return total;
  }

//------------------------------ PARTIAL CLOSE MANAGER (ORIGINAL+PATCH) ----------------------------

void PartialCloseManager()
  {
   for(int i=0; i<PositionsTotal(); i++)
     {
      if(PositionGetString(POSITION_SYMBOL)!=symbol_main) continue;

      double profit = PositionGetDouble(POSITION_PROFIT);
      double volume = PositionGetDouble(POSITION_VOLUME);
      ulong ticket  = PositionGetTicket(i);

      // Partial Close 1
      if(profit>=PartialClose1 && volume>PartialLot1*Lots)
        {
         trade.PositionClosePartial(ticket,PartialLot1*Lots);
         if(SoundOn) PlaySoundCustom("partial1.wav");
        }
      // Partial Close 2
      if(profit>=PartialClose2 && volume>PartialLot2*Lots)
        {
         trade.PositionClosePartial(ticket,PartialLot2*Lots);
         if(SoundOn) PlaySoundCustom("partial2.wav");
        }
     }
  }

//------------------------------ TRAILING STOP MANAGER (ORIGINAL+PATCH) ----------------------------

void TrailingStopManager()
  {
   if(!UseTrailingStop) return;
   for(int i=0; i<PositionsTotal(); i++)
     {
      if(PositionGetString(POSITION_SYMBOL)!=symbol_main) continue;
      ulong ticket = PositionGetTicket(i);
      double open_price = PositionGetDouble(POSITION_PRICE_OPEN);
      double stop_loss = PositionGetDouble(POSITION_SL);
      double volume = PositionGetDouble(POSITION_VOLUME);
      int type = (int)PositionGetInteger(POSITION_TYPE);

      if(type==POSITION_TYPE_BUY)
        {
         double new_sl = Bid - TrailingStop * _Point;
         if(new_sl>stop_loss+TrailingStep*_Point)
            trade.PositionModify(ticket,NormalizeDouble(new_sl,_Digits),PositionGetDouble(POSITION_TP));
        }
      else if(type==POSITION_TYPE_SELL)
        {
         double new_sl = Ask + TrailingStop * _Point;
         if(new_sl<stop_loss-TrailingStep*_Point || stop_loss==0)
            trade.PositionModify(ticket,NormalizeDouble(new_sl,_Digits),PositionGetDouble(POSITION_TP));
        }
     }
  }

//------------------------------ FULL CLOSE MANAGER (PATCH) ----------------------------

void FullCloseAll()
  {
   for(int i=0; i<PositionsTotal(); i++)
     {
      if(PositionGetString(POSITION_SYMBOL)==symbol_main)
        {
         ulong ticket = PositionGetTicket(i);
         trade.PositionClose(ticket);
        }
     }
   if(SoundOn) PlaySoundCustom("fullclose.wav");
  }

//------------------------------ FONCTION SOUND (PATCH) ----------------------------

void PlaySoundCustom(string filename)
  {
   if(allow_sound)
      PlaySound(filename);
  }

//--------------------------------------------------------------------
//                Partie 3 : Daily stats, gestion des events, système
//--------------------------------------------------------------------

//------------------------------ DAILY STATS (PATCH PRO) ----------------------------

void UpdateDailyStatsAfterTrade(double profit)
  {
   datetime today = DateOfDay(TimeCurrent());
   int idx = -1;
   for(int i=0; i<ArraySize(day_stats); i++)
     {
      if(day_stats[i].Day == today)
        {
         idx = i;
         break;
        }
      if(day_stats[i].Day == 0 && idx == -1)
         idx = i;
     }
   if(idx >= 0)
     {
      day_stats[idx].Day = today;
      day_stats[idx].Profit += profit;
      day_stats[idx].Trades++;
      // TODO: calcul MaxDrawdown si tu veux
     }
  }

datetime DateOfDay(datetime t)
  {
   MqlDateTime tm;
   TimeToStruct(t, tm);
   tm.hour = 0; tm.min = 0; tm.sec = 0;
   return StructToTime(tm);
  }

//------------------------------ GESTION EVENEMENTS SYSTEME ----------------------------

void OnTradeTransaction(
   const MqlTradeTransaction &trans,
   const MqlTradeRequest &request,
   const MqlTradeResult &result)
  {
   // PATCH : mise à jour stats, dashboard, etc.
   if(trans.type==TRADE_TRANSACTION_DEAL_ADD ||
      trans.type==TRADE_TRANSACTION_DEAL_UPDATE)
     {
      if(trans.deal_type == DEAL_TYPE_BUY || trans.deal_type == DEAL_TYPE_SELL)
        {
         double profit = trans.profit;
         UpdateDailyStatsAfterTrade(profit);
         dashboard_needs_update = true;
        }
     }
  }

//------------------------------ RESET ALL (PATCH) ----------------------------

void ResetAll()
  {
   InitGlobalVars();
   InitializeIndicators();
   dashboard_needs_update = true;
  }

//------------------------------ SYSTEME DE BASE MQL5 ----------------------------

int OnInit()
  {
   ResetAll();
   CheckGoldSymbol();
   InitializeIndicators();
   // PATCH : initialisation dashboard
   UpdateDashboard();
   EventSetTimer(60); // MAJ dashboard toutes les minutes
   return(INIT_SUCCEEDED);
  }

void OnDeinit(const int reason)
  {
   DeleteDashboard();
   EventKillTimer();
  }

void OnTick()
  {
   UpdateIndicators();
   ExecuteStrategies();
   PartialCloseManager();
   TrailingStopManager();
   if(full_close_triggered)
     {
      FullCloseAll();
      full_close_triggered = false;
     }
   if(dashboard_needs_update)
      UpdateDashboard();
  }

void OnTimer()
  {
   dashboard_needs_update = true;
  }

void OnTrade()
  {
   dashboard_needs_update = true;
  }

void OnChartEvent(const int id,
                  const long &lparam,
                  const double &dparam,
                  const string &sparam)
  {
   // PATCH : gestion bouton dashboard (full close)
   if(id == CHARTEVENT_OBJECT_CLICK)
     {
      string btn = sparam;
      if(btn == "btn_fullclose")
        {
         full_close_triggered = true;
        }
     }
  }

//--------------------------------------------------------------------
//                Partie 4 : Dashboard PRO et gestion graphique
//--------------------------------------------------------------------

//------------------------------ DASHBOARD (PRO PATCH) ----------------------------

void UpdateDashboard()
  {
   DeleteDashboard();

   // Création du cadre principal
   dashboard_handle = ObjectCreate(0,"dashboard",OBJ_RECTANGLE_LABEL,0,0,0);
   ObjectSetInteger(0,"dashboard",OBJPROP_X,DashboardPosX);
   ObjectSetInteger(0,"dashboard",OBJPROP_Y,DashboardPosY);
   ObjectSetInteger(0,"dashboard",OBJPROP_CORNER,CORNER_LEFT_UPPER);
   ObjectSetInteger(0,"dashboard",OBJPROP_BGCOLOR,clrDarkSlateGray);
   ObjectSetInteger(0,"dashboard",OBJPROP_WIDTH,DashboardWidth);
   ObjectSetInteger(0,"dashboard",OBJPROP_HEIGHT,DashboardHeight);
   ObjectSetInteger(0,"dashboard",OBJPROP_SELECTABLE,false);
   ObjectSetInteger(0,"dashboard",OBJPROP_SELECTED,false);

   DrawDashboardHeader();
   DrawDashboardStats();
   DrawDashboardDaily();
   DrawDashboardButton();

   dashboard_needs_update = false;
  }

void DeleteDashboard()
  {
   ObjectDelete(0,"dashboard");
   ObjectDelete(0,"dashboard_header");
   ObjectDelete(0,"dashboard_stats");
   ObjectDelete(0,"dashboard_daily");
   ObjectDelete(0,"btn_fullclose");
  }

void DrawDashboardHeader()
  {
   string text = "DIAMOND PRO v20    |    Symbol: "+symbol_main+"    |    "+(is_gold?"GOLD MODE":"FX MODE");
   ObjectCreate(0,"dashboard_header",OBJ_LABEL,0,0,0);
   ObjectSetInteger(0,"dashboard_header",OBJPROP_X,DashboardPosX+10);
   ObjectSetInteger(0,"dashboard_header",OBJPROP_Y,DashboardPosY+10);
   ObjectSetInteger(0,"dashboard_header",OBJPROP_CORNER,CORNER_LEFT_UPPER);
   ObjectSetInteger(0,"dashboard_header",OBJPROP_COLOR,clrGold);
   ObjectSetInteger(0,"dashboard_header",OBJPROP_FONTSIZE,12);
   ObjectSetString(0,"dashboard_header",OBJPROP_TEXT,text);
  }

void DrawDashboardStats()
  {
   string text;
   double profit = AccountInfoDouble(ACCOUNT_PROFIT);
   double equity = AccountInfoDouble(ACCOUNT_EQUITY);
   double balance = AccountInfoDouble(ACCOUNT_BALANCE);
   int buys = CountOpenPositions(POSITION_TYPE_BUY);
   int sells = CountOpenPositions(POSITION_TYPE_SELL);

   text  = "Balance: "+DoubleToString(balance,2)+"\n";
   text += "Equity: "+DoubleToString(equity,2)+"\n";
   text += "Profit: "+DoubleToString(profit,2)+"\n";
   text += "Open Buys: "+IntegerToString(buys)+"    |    Open Sells: "+IntegerToString(sells)+"\n";
   text += "Lots: "+DoubleToString(calc_lot,2)+"    |    Risk%: "+DoubleToString(RiskPercent,2)+"\n";

   ObjectCreate(0,"dashboard_stats",OBJ_LABEL,0,0,0);
   ObjectSetInteger(0,"dashboard_stats",OBJPROP_X,DashboardPosX+10);
   ObjectSetInteger(0,"dashboard_stats",OBJPROP_Y,DashboardPosY+35);
   ObjectSetInteger(0,"dashboard_stats",OBJPROP_CORNER,CORNER_LEFT_UPPER);
   ObjectSetInteger(0,"dashboard_stats",OBJPROP_COLOR,clrWhite);
   ObjectSetInteger(0,"dashboard_stats",OBJPROP_FONTSIZE,10);
   ObjectSetString(0,"dashboard_stats",OBJPROP_TEXT,text);
  }

void DrawDashboardDaily()
  {
   string text="Day         P/L       Trades\n";
   for(int i=0; i<ArraySize(day_stats) && day_stats[i].Day>0; i++)
     {
      MqlDateTime tm;
      TimeToStruct(day_stats[i].Day,tm);
      string d = IntegerToString(tm.year,4)+"/"+IntegerToString(tm.mon,2)+"/"+IntegerToString(tm.day,2);
      text += d+"   "+DoubleToString(day_stats[i].Profit,2)+"     "+IntegerToString(day_stats[i].Trades)+"\n";
     }
   ObjectCreate(0,"dashboard_daily",OBJ_LABEL,0,0,0);
   ObjectSetInteger(0,"dashboard_daily",OBJPROP_X,DashboardPosX+220);
   ObjectSetInteger(0,"dashboard_daily",OBJPROP_Y,DashboardPosY+35);
   ObjectSetInteger(0,"dashboard_daily",OBJPROP_CORNER,CORNER_LEFT_UPPER);
   ObjectSetInteger(0,"dashboard_daily",OBJPROP_COLOR,clrAqua);
   ObjectSetInteger(0,"dashboard_daily",OBJPROP_FONTSIZE,8);
   ObjectSetString(0,"dashboard_daily",OBJPROP_TEXT,text);
  }

void DrawDashboardButton()
  {
   ObjectCreate(0,"btn_fullclose",OBJ_BUTTON,0,0,0);
   ObjectSetInteger(0,"btn_fullclose",OBJPROP_X,DashboardPosX+10);
   ObjectSetInteger(0,"btn_fullclose",OBJPROP_Y,DashboardPosY+DashboardHeight-40);
   ObjectSetInteger(0,"btn_fullclose",OBJPROP_CORNER,CORNER_LEFT_UPPER);
   ObjectSetInteger(0,"btn_fullclose",OBJPROP_WIDTH,120);
   ObjectSetInteger(0,"btn_fullclose",OBJPROP_HEIGHT,30);
   ObjectSetInteger(0,"btn_fullclose",OBJPROP_BGCOLOR,clrRed);
   ObjectSetInteger(0,"btn_fullclose",OBJPROP_COLOR,clrWhite);
   ObjectSetInteger(0,"btn_fullclose",OBJPROP_BORDER_TYPE,BORDER_RAISED);
   ObjectSetString(0,"btn_fullclose",OBJPROP_TEXT,"FULL CLOSE");
   ObjectSetInteger(0,"btn_fullclose",OBJPROP_FONTSIZE,12);
  }


//--------------------------------------------------------------------
//                Partie 5 : FIN, Conseils d’assemblage et ajustements
//--------------------------------------------------------------------

//-------------------- CONSEILS D’UTILISATION ET AJUSTEMENTS ----------------------------

// 1. Pour activer/désactiver une stratégie, configure le tableau strategies[] dans OnInit().
// 2. Pour ajouter tes propres modules/indicateurs, ajoute-les dans la zone réservée (déclarée dans Partie 1).
// 3. Pour ajouter/améliorer une sortie partielle, adapte la fonction PartialCloseManager()
//    en utilisant tes propres indicateurs ou seuils personnalisés.
// 4. Pour ajuster la gestion Gold/XAUUSD, modifie la fonction CheckGoldSymbol() et les inputs associés.
// 5. Dashboard PRO : personnalise les couleurs, police, affichage dans les fonctions DrawDashboard*().
// 6. Pour le money management : la fonction CalcDynamicLot() est optimisée mais tu peux la remplacer
//    ou la compléter avec ton propre calcul basé sur tes indicateurs personnalisés.
// 7. Pour toute nouvelle stratégie, ajoute une fonction, référence-la dans ExecuteStrategies().

//-------------------- INITIALISATION DES STRATEGIES PAR DEFAUT ----------------------------

int strategies_total_init()
  {
   strategies_total = 0;
   strategies[0].Name = "SMA Crossover";
   strategies[0].Enabled = true;
   strategies_total++;
   strategies[1].Name = "Breakout";
   strategies[1].Enabled = true;
   strategies_total++;
   strategies[2].Name = "RSI";
   strategies[2].Enabled = true;
   strategies_total++;
   strategies[3].Name = "MACD";
   strategies[3].Enabled = true;
   strategies_total++;
   strategies[4].Name = "BBands";
   strategies[4].Enabled = true;
   strategies_total++;
   // Ajoute ici d’autres stratégies perso si besoin
   return(strategies_total);
  }

int OnInit()
  {
   ResetAll();
   CheckGoldSymbol();
   InitializeIndicators();
   strategies_total_init(); // <-- Initialisation
   UpdateDashboard();
   EventSetTimer(60); // MAJ dashboard toutes les minutes
   return(INIT_SUCCEEDED);
  }

//-------------------- FIN DU CODE PRINCIPAL ----------------------------

//+------------------------------------------------------------------+
//|      Copilot x amirbs14 - DIAMOND PRO v20 - Juin 2025            |
//+------------------------------------------------------------------+

