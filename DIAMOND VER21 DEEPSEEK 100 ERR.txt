//+------------------------------------------------------------------+
//|                     SBS DIAMOND PRO Ver 20                      |
//|                  Multi-strategy Expert Advisor (EA)              |
//|                 Compatible with GOLD (Gold/XAUUSD)               |
//|                 Author: amirbs14 - github.com/amirbs14           |
//+------------------------------------------------------------------+

#property copyright "amirbs14"
#property link      "https://github.com/amirbs14"
#property version   "20.0"
#property strict

//--- Panel colors and dashboard design
#define COLOR_PANEL_BG  clrGainsboro
#define COLOR_HEADER    clrOrange
#define COLOR_BTN_CLOSE clrRed

//--- Input parameters (expert settings)
input double    InitialLot        = 0.01;     // Initial lot size for trades
input double    MaxLot            = 5.0;      // Maximum allowed lot size
input double    RiskPercent       = 1.0;      // Risk per trade (% of balance)
input int       MagicNumber       = 20200520; // Unique magic number for orders
input int       Slippage          = 5;        // Max slippage (points)
input int       ATRPeriod         = 14;       // ATR period for volatility filter
input int       DashboardPosX     = 10;       // Dashboard X position (pixels)
input int       DashboardPosY     = 10;       // Dashboard Y position (pixels)
input int       DashboardWidth    = 420;      // Dashboard width (pixels)
input int       DashboardHeight   = 220;      // Dashboard height (pixels)
input bool      EnableSound       = true;     // Enable sound alerts

//--- Enums
enum ENUM_STRATEGY {
   STRAT_NONE = 0,
   STRAT_CHECKLIST = 1,
   STRAT_BREAKOUT_RANGE = 2,
   STRAT_PULLBACK_EMA = 3,
   STRAT_SUPERTREND = 4,
   STRAT_RETEST_SR = 5,
   STRAT_SCALPING = 6
};

//--- Structures
struct SStrategyPerformance {
   ENUM_STRATEGY strategy;
   int totalTrades;
   int wins;
   int losses;
   double totalProfit;
   double winRate;
   double profitFactor;
   bool enabled;
   datetime lastTradeTime;
   double weight;
};

struct STradeSignal {
   bool valid;
   bool isBuySignal;
   double price;
   double sl;
   double tp;
   ENUM_STRATEGY strategy;
   string comment;
};

struct SSymbolStats {
   string symbol;
   int totalTrades;
   int winTrades;
   int lossTrades;
   int todayTrades;
   int todayWins;
   int todayLosses;
   double spreadSum;
   int spreadCount;
   double spreadMax;
   double lastSpread;
};

//--- Strategy tracking structures
struct StrategyStats {
   string  Name;                // Strategy name
   bool    Enabled;             // Is this strategy enabled
   int     TotalTrades;         // Number of trades
   int     Wins;                // Number of winning trades
   int     Losses;              // Number of losing trades
   double  Profit;              // Total profit for this strategy
   double  WinRate;             // Win rate (%)
   color   StatusColor;         // Color for dashboard display
};

//--- Daily stats structure
struct DailyStats {
   datetime Day;
   double   Profit;
   int      Trades;
   double   MaxDrawdown;
};

//--- Global variables
double          g_LastEquity      = 0.0;      // Stores last equity value
double          g_LastBalance     = 0.0;      // Stores last balance value
double          g_ATRValue        = 0.0;      // Current ATR value
string          g_SymbolGold1     = "Gold";   // Symbol name for GOLD (XM and others)
string          g_SymbolGold2     = "XAUUSD"; // Symbol name for GOLD (most brokers)
bool            g_IsGold          = false;    // True if trading GOLD

//--- Example array for strategies (expand as needed)
StrategyStats strategies[];
int strategies_total = 0;        // Will be set after init
DailyStats day_stats[];

//--- Timer and dashboard variables
long dashboard_handle = -1;      // Graphical panel handle
bool dashboard_needs_update = true;

//--- Constants
#define MAX_SYMBOLS 20
#define MAX_RETRIES 3
#define STRATEGY_COUNT 6
#define MAX_POSITIONS_PER_SYMBOL 3

//--- Includes
#include <Trade\Trade.mqh>
#include <Trade\PositionInfo.mqh>
#include <Trade\HistoryOrderInfo.mqh>
#include <Trade\DealInfo.mqh>
#include <Math\Stat\Math.mqh>
#include <Arrays\ArrayObj.mqh>
#include <Generic\ArrayList.mqh>

//--- Global objects
CTrade trade;
CPositionInfo positionInfo;
CHistoryOrderInfo historyOrder;
CDealInfo dealInfo;
int macdHandle;
int rsiHandle;

datetime lastPerformanceSaveTime = 0;
const int PERFORMANCE_SAVE_INTERVAL = 3600; // Sauvegarde toutes les heures

SStrategyPerformance strategyPerformance[STRATEGY_COUNT];
SSymbolStats stats[MAX_SYMBOLS];
int symbolCount = 0;

datetime lastTradeTime = 0;
ulong lastTradeTicket = 0;

//--- Classes
class CRiskManager {
private:
   double maxDailyLossPercent;
   double maxLossPercent;
   int maxConsecutiveLosses;
   int pauseAfterLosses;
   int pauseDurationMinutes;
   int consecutiveLosses;
   datetime pauseUntil;
   
public:
   CRiskManager(double dailyLossPct, double lossPct, int maxConsLoss, int pauseLoss, int pauseMin) :
      maxDailyLossPercent(dailyLossPct),
      maxLossPercent(lossPct),
      maxConsecutiveLosses(maxConsLoss),
      pauseAfterLosses(pauseLoss),
      pauseDurationMinutes(pauseMin),
      consecutiveLosses(0),
      pauseUntil(0) {}
   
   bool IsTradeAllowed();
   void UpdateTradeResult(double profit);
   double CalculatePositionSize(double entry, double stopLoss);
   int GetOpenPositionsCount(string symbol);
};

class CStrategyManager {
private:
   //int macdHandle, adxHandle, rsiHandle, bbHandle;
   //int emaHandle, ema200Handle, superTrendHandle;
   //int checklistMacdHandle;

public:
   int atrHandle;
   int macdHandle, adxHandle, rsiHandle, bbHandle;
   int emaHandle, ema200Handle, superTrendHandle;
   int checklistMacdHandle;

   bool InitializeIndicators();
   bool CheckIndicators();
   bool DetectSuperTrendSignal(STradeSignal &signal);
   bool DetectSRRetestSignal(STradeSignal &signal);
   bool DetectBreakoutSignal(STradeSignal &signal);
   bool DetectPullbackEMASignal(STradeSignal &signal);
   bool DetectScalpingSignal(STradeSignal &signal);
   bool ChecklistStrategySignal(STradeSignal &signal);
};

class CTradeManager {
private:
   CRiskManager *riskManager;
   CTrade trade;
   
public:
   CTradeManager(CRiskManager *manager) : riskManager(manager) {
      trade.SetExpertMagicNumber(MagicNumber);
      trade.SetMarginMode();
      trade.SetTypeFillingBySymbol(_Symbol);
   }
   
   bool ExecuteTrade(const STradeSignal &signal);
   void ManagePositions();
   void UpdateTrailingStop();
   bool CanOpenNewPosition(string symbol);
   void PartialClose(ulong ticket, double percentage);
};

//--- Global instances
CRiskManager riskManager(MaxDailyLossPercent, MaxLossPercent, MaxConsecutiveLosses, PauseAfterLosses, PauseDurationMinutes);
CStrategyManager strategyManager;
CTradeManager tradeManager(&riskManager);

//+------------------------------------------------------------------+
//| Utility Functions                                               |
//+------------------------------------------------------------------+

//--- Calculate ATR (Average True Range) value for current symbol and timeframe
double GetATR(int period = 14) {
   int handle = iATR(_Symbol, _Period, period);
   if(handle == INVALID_HANDLE)
      return(0.0);
   double atr[];
   if(CopyBuffer(handle, 0, 0, 2, atr) < 1) {
      IndicatorRelease(handle);
      return(0.0);
   }
   IndicatorRelease(handle);
   return(atr[0]);
}

//--- Calculate dynamic lot size based on risk percentage and stop loss
double CalcDynamicLot(double riskPercent) {
   // Calculate free margin and risk per trade
   double freeMargin = AccountInfoDouble(ACCOUNT_FREEMARGIN);
   double riskMoney  = AccountInfoDouble(ACCOUNT_BALANCE) * riskPercent / 100.0;
   double stopLossPoints = 200; // Default stop loss in points (should be adapted per strategy)
   double tickValue   = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize    = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double lotStep     = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   double minLot      = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot      = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);

   // If ATR is available, use it as SL
   double atr = GetATR(ATRPeriod);
   if(atr > 0)
      stopLossPoints = atr * 2 / SymbolInfoDouble(_Symbol, SYMBOL_POINT);

   double lot = riskMoney / (stopLossPoints * tickValue / SymbolInfoDouble(_Symbol, SYMBOL_POINT));
   lot = MathMax(minLot, lot);
   lot = MathMin(maxLot, lot);
   lot = MathFloor(lot / lotStep) * lotStep;
   return(lot);
}

//--- Utility: Get color depending on value and thresholds
color GetValueColor(double val, double good, double bad) {
   // Return green if >= good, red if <= bad, yellow otherwise
   if(val >= good)
      return(clrLime);
   if(val <= bad)
      return(clrRed);
   return(clrYellow);
}

//--- Utility: Format double with sign for dashboard
string FormatSigned(double value, int digits=2) {
   if(value >= 0.0)
      return("+" + DoubleToString(value, digits));
   return(DoubleToString(value, digits));
}

//--- Update strategies statistics (winrate, colors, etc.)
void RefreshStrategyStats() {
   for(int i=0; i<strategies_total; i++) {
      StrategyStats &s = strategies[i];
      if(s.TotalTrades > 0)
         s.WinRate = 100.0 * s.Wins / s.TotalTrades;
      else
         s.WinRate = 0.0;
      if(!s.Enabled)
         s.StatusColor = clrSilver;
      else if(s.WinRate >= 60.0)
         s.StatusColor = clrDeepSkyBlue;
      else if(s.WinRate >= 50.0)
         s.StatusColor = clrLime;
      else if(s.WinRate >= 40.0)
         s.StatusColor = clrYellow;
      else
         s.StatusColor = clrRed;
   }
}

//--- Update daily statistics (profit, number of trades, max drawdown)
void UpdateDailyStats() {
   datetime today = DateOfDay(TimeCurrent());
   int idx = -1;
   for(int i=0; i<ArraySize(day_stats); i++) {
      if(day_stats[i].Day == today) {
         idx = i;
         break;
      }
   }
   if(idx == -1) {
      ArrayResize(day_stats, ArraySize(day_stats)+1);
      idx = ArraySize(day_stats)-1;
      day_stats[idx].Day = today;
      day_stats[idx].Profit = 0.0;
      day_stats[idx].Trades = 0;
      day_stats[idx].MaxDrawdown = 0.0;
   }
   // Logic to update today's stats will be implemented in trading section
}

//--- Utility: Get the day from datetime (at 00:00:00)
datetime DateOfDay(datetime t) {
   MqlDateTime str;
   TimeToStruct(t, str);
   str.hour = 0;
   str.min = 0;
   str.sec = 0;
   return(StructToTime(str));
}

//--- Utility: Check if symbol is GOLD ("Gold" or "XAUUSD")
bool IsGold() {
   return(StringFind(_Symbol, g_SymbolGold1) >= 0 || StringFind(_Symbol, g_SymbolGold2) >= 0);
}

//--- Placeholder for anomaly detection (to be filled in main logic)
// Returns true if an anomaly is detected (for full close)
bool DetectMarketAnomaly() {
   // Example: if spread > X, or ATR spike, etc.
   double spread = (SymbolInfoInteger(_Symbol, SYMBOL_SPREAD)) * SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   if(spread > 10 * SymbolInfoDouble(_Symbol, SYMBOL_POINT)) // Example threshold
      return(true);
   // Add more anomaly conditions as needed
   return(false);
}

//+------------------------------------------------------------------+
//| CRiskManager implementation                                     |
//+------------------------------------------------------------------+
bool CRiskManager::IsTradeAllowed() {
   if(pauseUntil > TimeCurrent()) {
      Print("Trading paused until ", TimeToString(pauseUntil));
      return false;
   }
   
   double dailyProfit = AccountInfoDouble(ACCOUNT_PROFIT);
   double balance = AccountInfoDouble(ACCOUNT_BALANCE);
   
   if(dailyProfit < 0 && MathAbs(dailyProfit) >= balance * maxDailyLossPercent / 100.0) {
      if(EnableNotifications) MySendNotification("Trading paused: Daily loss limit reached");
      return false;
   }
   
   if(consecutiveLosses >= maxConsecutiveLosses) {
      pauseUntil = TimeCurrent() + pauseDurationMinutes * 60;
      if(EnableNotifications) MySendNotification(StringFormat("Trading paused after %d consecutive losses", consecutiveLosses));
      return false;
   }
   
   return true;
}

void CRiskManager::UpdateTradeResult(double profit) {
   if(profit < 0) {
      consecutiveLosses++;
      if(consecutiveLosses % pauseAfterLosses == 0) {
         pauseUntil = TimeCurrent() + pauseDurationMinutes * 60;
         if(EnableNotifications) MySendNotification(StringFormat("Trading paused after %d loss streak", consecutiveLosses));
      }
   } else {
      consecutiveLosses = 0;
   }
}

double CRiskManager::CalculatePositionSize(double entry, double stopLoss) {
   double riskAmount = AccountInfoDouble(ACCOUNT_BALANCE) * RiskPercent / 100.0;
   double riskPoints = MathAbs(entry - stopLoss) / _Point;
   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   
   if(riskPoints <= 0 || tickValue <= 0) {
      Print("Invalid risk calculation - Points: ", riskPoints, " TickValue: ", tickValue);
      return 0.1; // Valeur par défaut sécurisée
   }
   
   double lots = riskAmount / (riskPoints * tickValue);
   lots = NormalizeDouble(lots, 2);
   
   // Limiter la taille du lot entre 0.1 et 0.5 comme demandé
   lots = MathMax(0.1, MathMin(lots, 0.5));
   
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   return MathMax(minLot, MathMin(lots, maxLot));
}

int CRiskManager::GetOpenPositionsCount(string symbol) {
   int count = 0;
   for(int i = (int)PositionsTotal()-1; i >= 0; i--) {
      ulong ticket = PositionGetTicket((int)i);
      if(PositionSelectByTicket(ticket)) {
         if(PositionGetString(POSITION_SYMBOL) == symbol && 
            PositionGetInteger(POSITION_MAGIC) == MagicNumber) {
            count++;
         }
      }
   }
   return count;
}

//+------------------------------------------------------------------+
//| CTradeManager implementation                                    |
//+------------------------------------------------------------------+
bool CTradeManager::CanOpenNewPosition(string symbol) {
   // Vérification du nombre de positions
   if(riskManager.GetOpenPositionsCount(symbol) >= MAX_POSITIONS_PER_SYMBOL) {
      Print("Max positions (", MAX_POSITIONS_PER_SYMBOL, ") reached for ", symbol);
      return false;
   }
   
   // Filtre temporel entre les trades
   if(TimeCurrent() - lastTradeTime < MinMinutesBetweenTrades * 60) {
      Print("Minimum time between trades not reached (", MinMinutesBetweenTrades, " minutes required)");
      return false;
   }
   
   // Pour USDJPY, assouplir légèrement les conditions de volatilité
   if(symbol == "USDJPY") {
      double spread = SymbolInfoInteger(symbol, SYMBOL_SPREAD) * _Point;
      if(spread > 30 * _Point) { // 3 pips max pour USDJPY
         Print("Spread too high for USDJPY: ", spread/_Point*10, " pips");
         return false;
      }
   }
   else if(!IsGoodVolatility()) {
      Print("Volatility conditions not met for ", symbol);
      return false;
   }
   
   return true;
}

bool CTradeManager::ExecuteTrade(const STradeSignal &signal) {
   if(!CanOpenNewPosition(_Symbol)) {
      Print("Cannot open new position - maximum positions (", MAX_POSITIONS_PER_SYMBOL, ") reached for ", _Symbol);
      return false;
   }

   double lots = riskManager.CalculatePositionSize(signal.price, signal.sl);
   if(lots <= 0) return false;

   LogSignalDetails(signal, macdHandle, rsiHandle);

   bool result = signal.isBuySignal ? 
                trade.Buy(lots, _Symbol, signal.price, signal.sl, signal.tp, signal.comment) :
                trade.Sell(lots, _Symbol, signal.price, signal.sl, signal.tp, signal.comment);

   if(result) {
      ulong deal_ticket = trade.ResultDeal();
      double profit = 0.0;

      if(deal_ticket > 0) {
         profit = HistoryDealGetDouble(deal_ticket, DEAL_PROFIT);
      }

      riskManager.UpdateTradeResult(profit);
      
      // Notification seulement à l'ouverture comme demandé
      if(EnableNotifications) {
         string msg = StringFormat("New %s trade opened via %s. SL: %.5f TP: %.5f",
                                 signal.isBuySignal ? "BUY" : "SELL",
                                 EnumToString(signal.strategy),
                                 signal.sl,
                                 signal.tp);
         MySendNotification(msg);
      }
      return true;
   }
   
   Print("Trade execution failed. Error: ", GetLastError());
   return false;
}

//+------------------------------------------------------------------+
//| CStrategyManager implementation                                 |
//+------------------------------------------------------------------+
bool CStrategyManager::InitializeIndicators() {
   // Standard MACD
   macdHandle = iMACD(_Symbol, _Period, 12, 26, 9, PRICE_CLOSE);
   if(macdHandle == INVALID_HANDLE) {
      Print("Failed to create MACD indicator: ", GetLastError());
      return false;
   }
   
   // Checklist-specific MACD
   checklistMacdHandle = iMACD(_Symbol, _Period, Checklist_MACD_Fast, Checklist_MACD_Slow, Checklist_MACD_Signal, PRICE_CLOSE);
   if(checklistMacdHandle == INVALID_HANDLE) {
      Print("Failed to create Checklist MACD indicator: ", GetLastError());
      return false;
   }
   
   // ADX
   adxHandle = iADX(_Symbol, _Period, 14);
   if(adxHandle == INVALID_HANDLE) {
      Print("Failed to create ADX indicator: ", GetLastError());
      return false;
   }
   
   // ATR
   atrHandle = iATR(_Symbol, _Period, 14);
   if(atrHandle == INVALID_HANDLE) {
      Print("Failed to create ATR indicator: ", GetLastError());
      return false;
   }
   
   // RSI
   rsiHandle = iRSI(_Symbol, _Period, 14, PRICE_CLOSE);
   if(rsiHandle == INVALID_HANDLE) {
      Print("Failed to create RSI indicator: ", GetLastError());
      return false;
   }
   
   // Bollinger Bands
   bbHandle = iBands(_Symbol, _Period, 20, 0, 2.0, PRICE_CLOSE);
   if(bbHandle == INVALID_HANDLE) {
      Print("Failed to create Bollinger Bands indicator: ", GetLastError());
      return false;
   }
   
   // EMA 20
   emaHandle = iMA(_Symbol, _Period, 20, 0, MODE_EMA, PRICE_CLOSE);
   if(emaHandle == INVALID_HANDLE) {
      Print("Failed to create EMA indicator: ", GetLastError());
      return false;
   }
   
   // EMA 200 pour filtre de tendance
   ema200Handle = iMA(_Symbol, _Period, 200, 0, MODE_EMA, PRICE_CLOSE);
   if(ema200Handle == INVALID_HANDLE) {
      Print("Failed to create EMA200 indicator: ", GetLastError());
      return false;
   }
   
   // SuperTrend (custom indicator)
   if(EnableSuperTrend) {
      superTrendHandle = iCustom(_Symbol, _Period, "SuperTrend");
      if(superTrendHandle == INVALID_HANDLE) {
         Print("Warning: Failed to create SuperTrend indicator: ", GetLastError());
      }
   }
   
   return true;
}

bool CStrategyManager::CheckIndicators() {
   // Vérifie que tous les indicateurs sont valides
   if(macdHandle == INVALID_HANDLE || 
      checklistMacdHandle == INVALID_HANDLE || 
      adxHandle == INVALID_HANDLE || 
      atrHandle == INVALID_HANDLE || 
      rsiHandle == INVALID_HANDLE || 
      bbHandle == INVALID_HANDLE || 
      emaHandle == INVALID_HANDLE || 
      ema200Handle == INVALID_HANDLE) {
      Print("One or more indicator handles are invalid");
      return false;
   }
   
   // Vérification supplémentaire pour SuperTrend si activé
   if(EnableSuperTrend && superTrendHandle == INVALID_HANDLE) {
      Print("SuperTrend indicator is enabled but handle is invalid");
      return false;
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| SuperTrend Strategy Signal                                      |
//+------------------------------------------------------------------+
bool CStrategyManager::DetectSuperTrendSignal(STradeSignal &signal) {
   if(superTrendHandle == INVALID_HANDLE || !EnableSuperTrend) return false;
   
   double upper[], lower[];
   ArraySetAsSeries(upper, true); ArraySetAsSeries(lower, true);
   
   if(CopyBuffer(superTrendHandle, 0, 0, 3, upper) != 3 || 
      CopyBuffer(superTrendHandle, 1, 0, 3, lower) != 3) {
      return false;
   }
   
   double close1 = iClose(_Symbol, _Period, 1), close2 = iClose(_Symbol, _Period, 2);

   // Buy signal
   if(close2 <= lower[1] && close1 > lower[0]) {
      signal.valid = true;
      signal.isBuySignal = true;
      signal.strategy = STRAT_SUPERTREND;
      signal.price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      SetStopTp(signal, true);
      signal.comment = "SuperTrend Buy";
      return true;
   }
   // Sell signal
   if(close2 >= upper[1] && close1 < upper[0]) {
      signal.valid = true;
      signal.isBuySignal = false;
      signal.strategy = STRAT_SUPERTREND;
      signal.price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
      SetStopTp(signal, false);
      signal.comment = "SuperTrend Sell";
      return true;
   }
   return false;
}

//+------------------------------------------------------------------+
//| Support/Resistance Retest Strategy Signal                       |
//+------------------------------------------------------------------+
bool CStrategyManager::DetectSRRetestSignal(STradeSignal &signal) {
   double levels[];
   int count = LoadSRLevels(levels);
   if(count < 2) return false;

   double close = iClose(_Symbol, _Period, 1);
   double prevClose = iClose(_Symbol, _Period, 2);

   for(int i = 0; i < count; i++) {
      // Buy signal (support retest)
      if(MathAbs(close - levels[i]) < iATR(_Symbol, _Period, 14) * 0.3 &&
         prevClose > levels[i] &&
         close < levels[i]) {
         signal.valid = true;
         signal.isBuySignal = true;
         signal.strategy = STRAT_RETEST_SR;
         signal.price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
         SetStopTp(signal, true);
         signal.comment = "Support Retest Buy";
         return true;
      }
      // Sell signal (resistance retest)
      if(MathAbs(close - levels[i]) < iATR(_Symbol, _Period, 14) * 0.3 &&
         prevClose < levels[i] &&
         close > levels[i]) {
         signal.valid = true;
         signal.isBuySignal = false;
         signal.strategy = STRAT_RETEST_SR;
         signal.price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
         SetStopTp(signal, false);
         signal.comment = "Resistance Retest Sell";
         return true;
      }
   }
   return false;
}

//+------------------------------------------------------------------+
//| Breakout Strategy Signal                                        |
//+------------------------------------------------------------------+
bool CStrategyManager::DetectBreakoutSignal(STradeSignal &signal) {
   double upperBand[], lowerBand[], close[];
   ArraySetAsSeries(upperBand, true);
   ArraySetAsSeries(lowerBand, true);
   ArraySetAsSeries(close, true);

   if(CopyBuffer(bbHandle, UPPER_BAND, 0, 3, upperBand) != 3 ||
      CopyBuffer(bbHandle, LOWER_BAND, 0, 3, lowerBand) != 3 ||
      CopyClose(_Symbol, _Period, 0, 3, close) != 3) {
      return false;
   }

   // Buy signal (breakout above upper band)
   if(close[1] > upperBand[1] && close[2] <= upperBand[2]) {
      signal.valid = true;
      signal.isBuySignal = true;
      signal.strategy = STRAT_BREAKOUT_RANGE;
      signal.price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      SetStopTp(signal, true);
      signal.comment = "Breakout Buy";
      return true;
   }
   // Sell signal (breakout below lower band)
   if(close[1] < lowerBand[1] && close[2] >= lowerBand[2]) {
      signal.valid = true;
      signal.isBuySignal = false;
      signal.strategy = STRAT_BREAKOUT_RANGE;
      signal.price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
      SetStopTp(signal, false);
      signal.comment = "Breakout Sell";
      return true;
   }
   return false;
}

//+------------------------------------------------------------------+
//| EMA Pullback Strategy Signal                                    |
//+------------------------------------------------------------------+
bool CStrategyManager::DetectPullbackEMASignal(STradeSignal &signal) {
   double ema[], ema200[], close[];
   ArraySetAsSeries(ema, true); ArraySetAsSeries(ema200, true); ArraySetAsSeries(close, true);
   
   if(CopyBuffer(emaHandle, 0, 0, 3, ema) != 3 ||
      CopyBuffer(ema200Handle, 0, 0, 1, ema200) != 1 ||
      CopyClose(_Symbol, _Period, 0, 3, close) != 3) return false;
   
   // Uptrend
   if(close[2] > ema[2] && close[1] <= ema[1] && close[0] > ema[0] && close[0] > ema200[0]) {
      signal.valid = true; signal.isBuySignal = true; signal.strategy = STRAT_PULLBACK_EMA;
      signal.price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      SetStopTp(signal, true);
      signal.comment = "EMA Pullback Buy";
      return true;
   }
   // Downtrend
   if(close[2] < ema[2] && close[1] >= ema[1] && close[0] < ema[0] && close[0] < ema200[0]) {
      signal.valid = true; signal.isBuySignal = false; signal.strategy = STRAT_PULLBACK_EMA;
      signal.price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
      SetStopTp(signal, false);
      signal.comment = "EMA Pullback Sell";
      return true;
   }
   return false;
}

//+------------------------------------------------------------------+
//| Scalping Strategy Signal                                        |
//+------------------------------------------------------------------+
bool CStrategyManager::DetectScalpingSignal(STradeSignal &signal)
{
   double macd[], signalLine[], rsi[];
   ArraySetAsSeries(macd, true);
   ArraySetAsSeries(signalLine, true);
   ArraySetAsSeries(rsi, true);

   if(CopyBuffer(macdHandle, MAIN_LINE, 0, 2, macd) != 2 ||
      CopyBuffer(macdHandle, SIGNAL_LINE, 0, 2, signalLine) != 2 ||
      CopyBuffer(rsiHandle, 0, 0, 1, rsi) != 1) {
      return false;
   }

   double spread = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD) * _Point;
   if(spread > 15 * _Point) return false;

   // Buy signal (MACD crossing up with RSI > 50)
   if(macd[0] > signalLine[0] && macd[1] <= signalLine[1] && rsi[0] > 50) {
      signal.valid = true;
      signal.isBuySignal = true;
      signal.strategy = STRAT_SCALPING;
      signal.price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      SetStopTp(signal, true);
      signal.comment = "Scalping Buy";
      return true;
   }
   // Sell signal (MACD crossing down with RSI < 50)
   if(macd[0] < signalLine[0] && macd[1] >= signalLine[1] && rsi[0] < 50) {
      signal.valid = true;
      signal.isBuySignal = false;
      signal.strategy = STRAT_SCALPING;
      signal.price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
      SetStopTp(signal, false);
      signal.comment = "Scalping Sell";
      return true;
   }
   return false;
}

//+------------------------------------------------------------------+
//| Checklist Strategy Signal                                       |
//+------------------------------------------------------------------+
bool CStrategyManager::ChecklistStrategySignal(STradeSignal &signal)
{
   double macd[], signalLine[];
   ArraySetAsSeries(macd, true);
   ArraySetAsSeries(signalLine, true);

   if(CopyBuffer(checklistMacdHandle, MAIN_LINE, 0, 2, macd) != 2 ||
      CopyBuffer(checklistMacdHandle, SIGNAL_LINE, 0, 2, signalLine) != 2) {
      return false;
   }

   bool macdBullish = macd[0] > signalLine[0] && macd[1] > signalLine[1];
   bool macdBearish = macd[0] < signalLine[0] && macd[1] < signalLine[1];

   double rsi[];
   ArraySetAsSeries(rsi, true);
   if(CopyBuffer(rsiHandle, 0, 0, 1, rsi) != 1) return false;
   bool rsiOk = rsi[0] > Checklist_RSI_Min && rsi[0] < Checklist_RSI_Max;

   double adx[];
   ArraySetAsSeries(adx, true);
   if(CopyBuffer(adxHandle, 0, 0, 1, adx) != 1) return false;
   bool adxOk = adx[0] > Checklist_ADX_Min;

   double upperBand[], lowerBand[], close[];
   ArraySetAsSeries(upperBand, true);
   ArraySetAsSeries(lowerBand, true);
   ArraySetAsSeries(close, true);

   if(CopyBuffer(bbHandle, UPPER_BAND, 0, 1, upperBand) != 1 ||
      CopyBuffer(bbHandle, LOWER_BAND, 0, 1, lowerBand) != 1 ||
      CopyClose(_Symbol, _Period, 0, 1, close) != 1) {
      return false;
   }

   double atr = iATR(_Symbol, _Period, 14);
   bool nearUpper = (upperBand[0] - close[0]) < (atr * 0.5);
   bool nearLower = (close[0] - lowerBand[0]) < (atr * 0.5);

   if(macdBullish && rsiOk && adxOk && nearLower) {
      signal.valid = true;
      signal.isBuySignal = true;
      signal.strategy = STRAT_CHECKLIST;
      signal.price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      SetStopTp(signal, true);
      signal.comment = "Checklist Strategy Buy";
      return true;
   }
   if(macdBearish && rsiOk && adxOk && nearUpper) {
      signal.valid = true;
      signal.isBuySignal = false;
      signal.strategy = STRAT_CHECKLIST;
      signal.price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
      SetStopTp(signal, false);
      signal.comment = "Checklist Strategy Sell";
      return true;
   }
   return false;
}

//+------------------------------------------------------------------+
//| Check trading conditions                                        |
//+------------------------------------------------------------------+
bool CheckTradingConditions(STradeSignal &signal)
{
   signal.valid = false;
   
   if(!riskManager.IsTradeAllowed()) {
      Print("Trade not allowed by risk manager");
      return false;
   }
   
   if(TimeCurrent() - lastTradeTime < MinMinutesBetweenTrades * 60) {
      Print("Minimum time between trades not reached");
      return false;
   }
   
   if(!IsTradingTime() || !IsGoodVolatility()) {
      Print("Trading conditions not met - time or volatility");
      return false;
   }
   
   // Ajout du filtre de tendance EMA200
  if(false) { // Mettez true pour activer le filtre
   double ema200[];
   if(CopyBuffer(strategyManager.ema200Handle, 0, 0, 1, ema200) == 1) {
      double close = iClose(_Symbol, _Period, 1);
      if((signal.isBuySignal && close < ema200[0]) || (!signal.isBuySignal && close > ema200[0])) {
         Print("Trade filtered - contre tendance EMA200 (non rejeté)");
         // Ne pas return false, juste logger
      }
   }
   }
   
   for(int i = 0; i < STRATEGY_COUNT; i++) {
      if(!strategyPerformance[i].enabled) continue;
      
      bool strategySignal = false;
      switch(strategyPerformance[i].strategy) {
         case STRAT_SUPERTREND:
            strategySignal = strategyManager.DetectSuperTrendSignal(signal);
            break;
         case STRAT_RETEST_SR:
            strategySignal = strategyManager.DetectSRRetestSignal(signal);
            break;
         case STRAT_BREAKOUT_RANGE:
            strategySignal = strategyManager.DetectBreakoutSignal(signal);
            break;
         case STRAT_PULLBACK_EMA:
            strategySignal = strategyManager.DetectPullbackEMASignal(signal);
            break;
         case STRAT_SCALPING:
            strategySignal = strategyManager.DetectScalpingSignal(signal);
            break;
         case STRAT_CHECKLIST:
            strategySignal = strategyManager.ChecklistStrategySignal(signal);
            break;
      }
      
      if(strategySignal && ValidateTrade(signal)) {
         return true;
      }
   }
   
   return false;
}

//+------------------------------------------------------------------+
//| Check if current time is within trading hours                   |
//+------------------------------------------------------------------+
bool IsTradingTime()
{  
   // Retourne toujours true pour trader 24h/24
   return true;
}

//+------------------------------------------------------------------+
//| Check volatility conditions                                     |
//+------------------------------------------------------------------+
bool IsGoodVolatility() 
{
   double atr = iATR(_Symbol, _Period, 14);
   double spread = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD) * _Point;

   double atrThreshold, spreadThreshold;
   if(_Symbol=="USDJPY") {
      atrThreshold = 0.15; // suggestion : abaisse à 0.15 (M30)
      spreadThreshold = 40 * _Point; // 4 pips
   } else {
      atrThreshold = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE) * 30;
      spreadThreshold = 15 * _Point; // 1.5 pips
   }
   bool volatilityOk = (atr > atrThreshold);
   bool spreadOk = (spread < spreadThreshold);

   if(!volatilityOk) PrintFormat("ATR %.5f < seuil %.5f", atr, atrThreshold);
   if(!spreadOk) PrintFormat("Spread %.1f pips > seuil %.1f", spread/_Point*10, spreadThreshold/_Point*10);

   return (volatilityOk && spreadOk);
}

//+------------------------------------------------------------------+
//| Update strategy weights based on performance                    |
//+------------------------------------------------------------------+
void UpdateStrategyWeights()
{
   for(int i = 0; i < STRATEGY_COUNT; i++) {
      if(strategyPerformance[i].totalTrades < 5) continue;
      
      double recentWinRate = strategyPerformance[i].wins / (double)MathMax(20, strategyPerformance[i].totalTrades) * 100.0;
      double mediumWinRate = strategyPerformance[i].wins / (double)MathMax(100, strategyPerformance[i].totalTrades) * 100.0;
      
      double atr = iATR(_Symbol, _Period, 14);
      double volatilityFactor = (atr > 0.0005) ? 1.2 : (atr < 0.0002) ? 0.8 : 1.0;
      
      strategyPerformance[i].weight = recentWinRate * 0.5 + mediumWinRate * 0.3 + volatilityFactor * 0.2;
   }
}

//+------------------------------------------------------------------+
//| Strategy Performance Management                                 |
//+------------------------------------------------------------------+
void AutoManageStrategies()
{
   for(int i = 0; i < STRATEGY_COUNT; i++) {
      if(strategyPerformance[i].totalTrades < MinTradesToDisable) continue;
      
      strategyPerformance[i].winRate = (double)strategyPerformance[i].wins / strategyPerformance[i].totalTrades * 100.0;
      
      if(strategyPerformance[i].winRate < MinWinRateToDisable) {
         strategyPerformance[i].enabled = false;
         strategyPerformance[i].lastTradeTime = TimeCurrent();
         if(EnableNotifications) {
            MySendNotification("Strategy Disabled: " + EnumToString(strategyPerformance[i].strategy) + 
                            " (Win Rate: " + DoubleToString(strategyPerformance[i].winRate, 1) + "%)");
         }
      }
      
      if(!strategyPerformance[i].enabled && 
         TimeCurrent() - strategyPerformance[i].lastTradeTime > ReEnableAfterHours * 3600) {
         strategyPerformance[i].enabled = true;
         if(EnableNotifications) {
            MySendNotification("Strategy Re-enabled: " + EnumToString(strategyPerformance[i].strategy));
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Load Support/Resistance Levels                                  |
//+------------------------------------------------------------------+
int LoadSRLevels(double &levels[])
{
   ArrayResize(levels, 0);
   int lookback = 100;
   int bars = (int)Bars(_Symbol, _Period);
   if(bars < lookback) lookback = bars;
   
   for(int i = 3; i < lookback-3; i++) {
      double high1 = iHigh(_Symbol, _Period, i+1);
      double high2 = iHigh(_Symbol, _Period, i);
      double high3 = iHigh(_Symbol, _Period, i-1);
      
      if(high2 > high1 && high2 > high3) {
         ArrayResize(levels, ArraySize(levels)+1);
         levels[ArraySize(levels)-1] = high2;
      }
      
      double low1 = iLow(_Symbol, _Period, i+1);
      double low2 = iLow(_Symbol, _Period, i);
      double low3 = iLow(_Symbol, _Period, i-1);
      
      if(low2 < low1 && low2 < low3) {
         ArrayResize(levels, ArraySize(levels)+1);
         levels[ArraySize(levels)-1] = low2;
      }
   }
   
   for(int i = 0; i < ArraySize(levels); i++) {
      for(int j = i+1; j < ArraySize(levels); j++) {
         if(MathAbs(levels[i] - levels[j]) < 10*_Point) {
            levels[i] = (levels[i] + levels[j]) / 2;
            for(int k = j; k < ArraySize(levels)-1; k++) {
               levels[k] = levels[k+1];
            }
            ArrayResize(levels, ArraySize(levels)-1);
            j--;
         }
      }
   }
   
   return ArraySize(levels);
}

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   // Vérification des paires autorisées
   string allowedSymbols[] = {"EURUSD", "USDJPY", "EURGBP", "USDGBP", "USDCAD", 
                             "AUDCAD", "AUDUSD", "GBPUSD", "USDCHF", "XAUUSD",
                             "BTCUSD"};
   bool symbolAllowed = false;
   for(int i=0; i<ArraySize(allowedSymbols); i++) {
      if(_Symbol == allowedSymbols[i]) {
         symbolAllowed = true;
         break;
      }
   }
   
   if(!symbolAllowed) {
      Alert("EA DIAMOND v17.1 can't Trade this Pair/Symbol ", _Symbol);
      return INIT_FAILED;
   }

   // Initialize global variables
   InitGlobalVars();
   CheckGoldSymbol();

   // Initialize strategies performance tracking
   for(int i = 0; i < STRATEGY_COUNT; i++) {
      strategyPerformance[i].strategy = (ENUM_STRATEGY)(i+1);
      strategyPerformance[i].enabled = true;
      strategyPerformance[i].weight = 1.0;
   }
   
   // Create indicator handles
   if(!strategyManager.InitializeIndicators()) {
      Print("Failed to initialize indicators!");
      return INIT_FAILED;
   }
   
   // Verify indicators
   if(!strategyManager.CheckIndicators()) {
      Print("Indicator check failed!");
      return INIT_FAILED;
   }
   
   // Initialize strategies
   InitializeStrategies();
   
   // Load historical performance data
   LoadStrategyPerformance();
   
   // Set up timer for periodic updates
   EventSetTimer(10);
   
   return INIT_SUCCEEDED;
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   // Save strategy performance data
   SaveStrategyPerformance();
   DeleteDashboard();
   ObjectsDeleteAll(0, "Dashboard_");
   EventKillTimer();
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   static datetime lastCheck = 0;
   // Vérifier les indicateurs toutes les 15 minutes
   if(TimeCurrent() - lastCheck >= 300) {
      if(!VerifyIndicators()) {
         Print("Indicator check failed in OnTick()!");
      }
      lastCheck = TimeCurrent();
   }

   // Update ATR and check gold status
   g_ATRValue = GetATR(ATRPeriod);
   g_IsGold = IsGold();

   // Intelligent exit logic
   CheckIntelligentExit();

   if(!tradeManager.CanOpenNewPosition(_Symbol)) {
      return;
   }
   
   STradeSignal signal;
   if(CheckTradingConditions(signal)) {
      OpenTrade(signal);
   }
   
   tradeManager.ManagePositions();
   tradeManager.UpdateTrailingStop();
   
   // Dashboard update
   if(dashboard_needs_update) {
      UpdateDashboard();
      dashboard_needs_update = false;
   }
}

//+------------------------------------------------------------------+
//| Timer function                                                   |
//+------------------------------------------------------------------+
void OnTimer()
{
   if(EnableStrategyAutoManagement) {
      AutoManageStrategies();
   }
   
   UpdateStrategyWeights();
   UpdateDashboard();
}

//+------------------------------------------------------------------+
//| Initialize global variables and structures                       |
//+------------------------------------------------------------------+
void InitGlobalVars()
{
   g_LastEquity  = AccountInfoDouble(ACCOUNT_EQUITY);
   g_LastBalance = AccountInfoDouble(ACCOUNT_BALANCE);
   g_ATRValue    = 0.0;
   dashboard_handle = -1;
   dashboard_needs_update = true;
}

//+------------------------------------------------------------------+
//| Detect if current symbol is GOLD (Gold or XAUUSD)                |
//+------------------------------------------------------------------+
void CheckGoldSymbol()
{
   g_IsGold = (StringFind(_Symbol, g_SymbolGold1) >= 0 || StringFind(_Symbol, g_SymbolGold2) >= 0);
}

//+------------------------------------------------------------------+
//| Function to close all open positions for this EA and symbol      |
//+------------------------------------------------------------------+
void PerformFullClose()
{
   int total = PositionsTotal();
   for(int i = total - 1; i >= 0; i--) {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket)) {
         string pos_symbol = PositionGetString(POSITION_SYMBOL);
         int pos_magic     = (int)PositionGetInteger(POSITION_MAGIC);
         if((pos_symbol == _Symbol) && (pos_magic == MagicNumber)) {
            double volume = PositionGetDouble(POSITION_VOLUME);
            ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            if(type == POSITION_TYPE_BUY) {
               trade.PositionClose(ticket, volume, SymbolInfoDouble(_Symbol, SYMBOL_BID), Slippage);
            }
            else if(type == POSITION_TYPE_SELL) {
               trade.PositionClose(ticket, volume, SymbolInfoDouble(_Symbol, SYMBOL_ASK), Slippage);
            }
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Check for intelligent exit: profit/loss thresholds & anomalies   |
//+------------------------------------------------------------------+
void CheckIntelligentExit()
{
   double totalProfit = 0.0;
   int openPositions = 0;
   int total = PositionsTotal();
   for(int i = 0; i < total; i++) {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket)) {
         string pos_symbol = PositionGetString(POSITION_SYMBOL);
         int pos_magic     = (int)PositionGetInteger(POSITION_MAGIC);
         if((pos_symbol == _Symbol) && (pos_magic == MagicNumber)) {
            totalProfit += PositionGetDouble(POSITION_PROFIT);
            openPositions++;
         }
      }
   }
   
   // Example thresholds (can be made into input parameters)
   double profitThreshold = 50.0;  // e.g. $50
   double lossThreshold   = -30.0; // e.g. -$30
   
   // Detect market anomaly
   bool anomaly = DetectMarketAnomaly();

   if(openPositions > 0) {
      // Full close on profit or loss threshold, or on anomaly
      if(totalProfit >= profitThreshold || totalProfit <= lossThreshold || anomaly) {
         Print("Full close triggered: total profit=", totalProfit, ", anomaly=", anomaly);
         PerformFullClose();
      }
   }
}

//+------------------------------------------------------------------+
//| Dashboard Functions                                             |
//+------------------------------------------------------------------+
void UpdateDashboard()
{
   // Delete existing dashboard to redraw
   DeleteDashboard();

   // Draw panel background
   dashboard_handle = ObjectCreate(0, "DASHBOARD_PANEL", OBJ_RECTANGLE_LABEL, 0, 0, 0);
   ObjectSetInteger(0, "DASHBOARD_PANEL", OBJPROP_XDISTANCE, DashboardPosX);
   ObjectSetInteger(0, "DASHBOARD_PANEL", OBJPROP_YDISTANCE, DashboardPosY);
   ObjectSetInteger(0, "DASHBOARD_PANEL", OBJPROP_XSIZE, DashboardWidth);
   ObjectSetInteger(0, "DASHBOARD_PANEL", OBJPROP_YSIZE, DashboardHeight);
   ObjectSetInteger(0, "DASHBOARD_PANEL", OBJPROP_CORNER, 0);
   ObjectSetInteger(0, "DASHBOARD_PANEL", OBJPROP_COLOR, COLOR_PANEL_BG);
   ObjectSetInteger(0, "DASHBOARD_PANEL", OBJPROP_BACK, true);
   ObjectSetInteger(0, "DASHBOARD_PANEL", OBJPROP_SELECTABLE, false);

   // Draw header
   DrawDashboardHeader();

   // Draw stats
   DrawDashboardStats();

   // Draw daily stats
   DrawDashboardDaily();

   // Draw close button
   DrawDashboardButton();
}

void DrawDashboardHeader()
{
   string objName = "DASHBOARD_HEADER";
   ObjectCreate(0, objName, OBJ_LABEL, 0, 0, 0);
   ObjectSetInteger(0, objName, OBJPROP_XDISTANCE, DashboardPosX + DashboardWidth/2 - 100);
   ObjectSetInteger(0, objName, OBJPROP_YDISTANCE, DashboardPosY + 8);
   ObjectSetInteger(0, objName, OBJPROP_CORNER, 0);
   ObjectSetInteger(0, objName, OBJPROP_COLOR, COLOR_HEADER);
   ObjectSetInteger(0, objName, OBJPROP_FONTSIZE, 14);
   ObjectSetString(0, objName, OBJPROP_TEXT, "SBS DIAMOND PRO Ver 20");
}

void DrawDashboardStats()
{
   int y = DashboardPosY + 36;
   for(int i=0; i<strategies_total; i++) {
      string objName = "DASHBOARD_STRAT_" + IntegerToString(i);
      StrategyStats &s = strategies[i];
      string txt = s.Name + " | Trades: " + IntegerToString(s.TotalTrades) +
                   " | WinRate: " + DoubleToString(s.WinRate,1) + "%" +
                   " | Profit: " + FormatSigned(s.Profit, 2);
      ObjectCreate(0, objName, OBJ_LABEL, 0, 0, 0);
      ObjectSetInteger(0, objName, OBJPROP_XDISTANCE, DashboardPosX + 15);
      ObjectSetInteger(0, objName, OBJPROP_YDISTANCE, y);
      ObjectSetInteger(0, objName, OBJPROP_COLOR, s.StatusColor);
      ObjectSetInteger(0, objName, OBJPROP_FONTSIZE, 11);
      ObjectSetString(0, objName, OBJPROP_TEXT, txt);
      y += 18;
   }

   // Account stats
   string balName = "DASHBOARD_BAL";
   ObjectCreate(0, balName, OBJ_LABEL, 0, 0, 0);
   ObjectSetInteger(0, balName, OBJPROP_XDISTANCE, DashboardPosX + 15);
   ObjectSetInteger(0, balName, OBJPROP_YDISTANCE, y+5);
   ObjectSetInteger(0, balName, OBJPROP_COLOR, clrBlue);
   ObjectSetInteger(0, balName, OBJPROP_FONTSIZE, 11);
   string accText = "Balance: " + DoubleToString(AccountInfoDouble(ACCOUNT_BALANCE),2) +
                    " | Equity: " + DoubleToString(AccountInfoDouble(ACCOUNT_EQUITY),2) +
                    " | FreeMargin: " + DoubleToString(AccountInfoDouble(ACCOUNT_FREEMARGIN),2);
   ObjectSetString(0, balName, OBJPROP_TEXT, accText);
}

void DrawDashboardDaily()
{
   string objName = "DASHBOARD_DAILY";
   ObjectCreate(0, objName, OBJ_LABEL, 0, 0, 0);
   ObjectSetInteger(0, objName, OBJPROP_XDISTANCE, DashboardPosX + 15);
   ObjectSetInteger(0, objName, OBJPROP_YDISTANCE, DashboardPosY + DashboardHeight - 50);
   ObjectSetInteger(0, objName, OBJPROP_COLOR, clrBlue);
   ObjectSetInteger(0, objName, OBJPROP_FONTSIZE, 11);
   string txt = "Today's Trades: " + IntegerToString(day_stats[ArraySize(day_stats)-1].Trades) +
                " | Daily Profit: " + FormatSigned(day_stats[ArraySize(day_stats)-1].Profit,2) +
                " | Max DD: " + DoubleToString(day_stats[ArraySize(day_stats)-1].MaxDrawdown,2);
   ObjectSetString(0, objName, OBJPROP_TEXT, txt);
}

void DrawDashboardButton()
{
   string objName = "DASHBOARD_CLOSE";
   ObjectCreate(0, objName, OBJ_RECTANGLE_LABEL, 0, 0, 0);
   ObjectSetInteger(0, objName, OBJPROP_XDISTANCE, DashboardPosX + DashboardWidth - 38);
   ObjectSetInteger(0, objName, OBJPROP_YDISTANCE, DashboardPosY + 8);
   ObjectSetInteger(0, objName, OBJPROP_XSIZE, 30);
   ObjectSetInteger(0, objName, OBJPROP_YSIZE, 22);
   ObjectSetInteger(0, objName, OBJPROP_COLOR, COLOR_BTN_CLOSE);
   ObjectSetInteger(0, objName, OBJPROP_BACK, false);

   string txtName = "DASHBOARD_CLOSE_TXT";
   ObjectCreate(0, txtName, OBJ_LABEL, 0, 0, 0);
   ObjectSetInteger(0, txtName, OBJPROP_XDISTANCE, DashboardPosX + DashboardWidth - 33);
   ObjectSetInteger(0, txtName, OBJPROP_YDISTANCE, DashboardPosY + 12);
   ObjectSetInteger(0, txtName, OBJPROP_COLOR, clrWhite);
   ObjectSetInteger(0, txtName, OBJPROP_FONTSIZE, 13);
   ObjectSetString(0, txtName, OBJPROP_TEXT, "X");
}

void DeleteDashboard()
{
   ObjectDelete(0, "DASHBOARD_PANEL");
   ObjectDelete(0, "DASHBOARD_HEADER");
   ObjectDelete(0, "DASHBOARD_BAL");
   ObjectDelete(0, "DASHBOARD_DAILY");
   ObjectDelete(0, "DASHBOARD_CLOSE");
   ObjectDelete(0, "DASHBOARD_CLOSE_TXT");
   for(int i=0; i<strategies_total; i++) {
      ObjectDelete(0, "DASHBOARD_STRAT_" + IntegerToString(i));
   }
}

//+------------------------------------------------------------------+
//| Initialize strategies (example initialization)                   |
//+------------------------------------------------------------------+
void InitializeStrategies()
{
   strategies_total = 2; // Example: two strategies, expand as needed
   ArrayResize(strategies, strategies_total);

   strategies[0].Name = "SMA Crossover";
   strategies[0].Enabled = true;
   strategies[0].TotalTrades = 0;
   strategies[0].Wins = 0;
   strategies[0].Losses = 0;
   strategies[0].Profit = 0.0;
   strategies[0].WinRate = 0.0;
   strategies[0].StatusColor = clrDeepSkyBlue;

   strategies[1].Name = "Breakout";
   strategies[1].Enabled = false; // Disabled by default, enable as needed
   strategies[1].TotalTrades = 0;
   strategies[1].Wins = 0;
   strategies[1].Losses = 0;
   strategies[1].Profit = 0.0;
   strategies[1].WinRate = 0.0;
   strategies[1].StatusColor = clrSilver;
}

//+------------------------------------------------------------------+
//| End of DIAMOND PRO v20                                          |
//+------------------------------------------------------------------+

